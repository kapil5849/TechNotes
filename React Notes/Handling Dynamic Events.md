# Dynamic Events and How to handle them

- Imagine you have a toy car that can make different sounds when you press its buttons. Each button on the car is like an event. When you press a button, something happens - like the car making a sound.

- In programming, dynamic events are like those buttons on the car. It's a way for your computer program to respond to actions or changes that happen while the program is running.

- For example, if you have a game where you control a character with the keyboard, pressing the "up" arrow key is an event. When you press it, the character moves up on the screen. When you press the "down" arrow key, that's another event, and it makes the character move down.

- In a web page, dynamic events can be things like clicking a button, typing in a text box, or moving the mouse over an image. When these events happen, you can make your web page do something special, like showing a popup or changing the color of a button.

- To handle dynamic events in programming, you need to tell your program what to do when a specific event occurs. It's like telling the toy car to make a honking sound when you press the horn button.

- In code, you set up functions or blocks of code to handle the events. When the event happens, your program runs those functions, and they do whatever you want them to do.

- So, handling dynamic events is like having your program listen for actions or changes, and when they happen, it responds in a specific way - just like your toy car making sounds when you press its buttons.

## Understanding Dynamic Events in React.js

- Dynamic events refer to events that are generated by user actions such as clicking, typing, scrolling, and hovering. In React.js, handling dynamic events involves creating event handlers that respond to these user actions and trigger specific functions or behaviors.

- To handle dynamic events in React.js, you first need to understand the event system in React. React uses a <b> synthetic event system </b>, which means that it abstracts away the differences between different browsers and provides a consistent interface for handling events.

## Creating Event Handlers in React.js

- Handling dynamic events in React.js is like making a toy car do different things when you press its buttons. In React.js, we use event handlers to respond to actions like clicking, typing, or scrolling on a web page.

- To create an event handler, we define a function that says what should happen when the event occurs. For example, we can make a button show an alert when clicked:

```jsx
function handleClick() {
  alert('Button clicked!');
}

<button onClick={handleClick}>Click me!</button>
```

One common dynamic event is `onChange`, which happens when you type something into a text field. We can create an event handler that logs the text you type:

```jsx
function handleChange(event) {
  console.log(event.target.value);
}

<input type="text" onChange={handleChange} />
```

### steps for creating the event handlers 

Step 1: Define the Event Handler Function
An event handler function is like a set of instructions for what should happen when a certain event occurs. In our example, let's create an event handler function called `handleClick` that will show an alert when a button is clicked.

```jsx
function handleClick() {
  alert('Button clicked!');
}
```

Here, we defined the `handleClick` function. It's like telling the computer, "Hey, when the button is clicked, I want you to show an alert saying `Button clicked!`

Step 2: Attach the Event Handler to an Element
Now that we have our event handler function, we need to tell React.js to use it when the button is clicked. We do this by attaching the `handleClick` function to the button using the `onClick` attribute.

```jsx
<button onClick={handleClick}>Click me!</button>
```

This line of code says, "Hey, when someone clicks this button, I want you to use the `handleClick` function we defined earlier."

Step 3: See It in Action
Now, when you open your web page and click the button, the magic happens! React.js listens for the click event on the button, and when it happens, it runs the `handleClick` function.

As a result, an alert pops up on the screen with the message "Button clicked!" That's because our `handleClick` function told React.js to show that alert when the button is clicked.

So, in simple words, creating an event handler in React.js is like telling your computer what to do when a specific event (like a button click) happens. You define a function to handle that event, and then you attach that function to the element where the event should be detected.

When the event occurs, React.js runs the function, and you get the desired behavior, like showing an alert or performing any other action you want.

In the example provided earlier, `handleClick` is the name of the event handler function, and `onClick` is an attribute that we use to attach the `handleClick` function to the button element.

1. `handleClick`: This is a custom function we defined to handle the click event on the button. It's like a set of instructions we want to run when the button is clicked. In this case, the function shows an alert with the message "Button clicked!".

```jsx
function handleClick() {
  alert('Button clicked!');
}
```

2. `onClick`: This is a special attribute provided by React.js that allows us to specify what function should be called when the element is clicked. It's a reserved word for React.js event handling.

```jsx
<button onClick={handleClick}>Click me!</button>
```

The `onClick` attribute is specifically designed to work with React.js and indicates that the `handleClick` function should be triggered when the button is clicked. It's like telling React.js, "Hey, when someone clicks this button, I want you to use the `handleClick` function we defined earlier." 

It's essential to use the correct attribute name (`onClick`) when working with React.js. This is because React.js has a specific event system that listens for events like clicks and other user actions. By using `onClick`, React.js knows exactly what to do when the button is clicked. 

Using a different word for the attribute, like `onPress` instead of `onClick`, will not work the same way because it's not recognized by React.js as a special event handler. In React.js, we need to use the correct event attribute names to make our event handlers work properly. 

So, to handle events in React.js, we must use the appropriate event attribute name (`onClick`, `onChange`, etc.) provided by React.js, and we should define our custom event handler functions (like `handleClick`) to perform specific actions when those events occur.

## Understanding Event Handling in React.js

### onChange Event

`onChange` is another event in React.js, and it is triggered when the value of an input element (like a text input, checkbox, or select dropdown) changes. This event is commonly used to handle user input and to update the application state accordingly.

For example, if you have an input field for the user to enter their name, you can use the `onChange` event to listen for any changes to the input value. When the user types or deletes characters in the input field, the `onChange` event will be fired, and you can access the updated value of the input.

Here's an example of how you can use `onChange` to handle user input in a text input:

```jsx
import React, { useState } from 'react';

const TextInput = () => {
  const [inputValue, setInputValue] = useState('');

  const handleChange = (event) => {
    setInputValue(event.target.value);
  };

  return (
    <div>
      <input
        type="text"
        value={inputValue}
        onChange={handleChange}
      />
      <p>You typed: {inputValue}</p>
    </div>
  );
};
```

In this example, we have a `TextInput` component that renders an input field and a paragraph below it. We use the `useState` hook to create a state variable called `inputValue` to store the current value of the input field.

The `handleChange` function is our event handler for the `onChange` event. When the user types or deletes characters in the input field, the `handleChange` function is called, and it updates the `inputValue` state to match the current value of the input.

As a result, the paragraph below the input field shows the text "You typed: " followed by the current value of the input field, reflecting the changes made by the user.

Using `onChange` is a fundamental technique for capturing user input and responding to it in React.js applications. It allows us to create dynamic and interactive user interfaces by updating the state of the components based on user actions.

### useState Hook

`useState` is a React.js hook that allows functional components to have state variables. It is one of the built-in hooks provided by React that enables you to add stateful behavior to functional components without using class components.

With `useState`, you can declare and manage state variables in your functional components, and React will automatically re-render the component whenever the state changes. This allows you to create dynamic and interactive user interfaces by updating the state and reflecting those changes in the UI.

Here's a basic example of how to use `useState` in a functional component:

```jsx
import React, { useState } from 'react';

const Counter = () => {
  // Declare a state variable called "count" with an initial value of 0
  const [count, setCount] = useState(0);

  // Function to increment the count
  const increment = () => {
    setCount(count + 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
};
```

In this example, we have a `Counter` component that displays a count value and a button. We use `useState` to create a state variable called `count` and initialize it with the value `0`.

The `useState` function returns an array with two elements: the current value of the state variable (`count`) and a function (`setCount`) to update the state. We use array destructuring to assign these elements to `count` and `setCount`.

When the button is clicked, the `increment` function is called, which uses `setCount` to update the `count` state by incrementing it by 1. As a result, the UI automatically reflects the updated value of the `count` state.

Using `useState`, you can handle more complex state management in functional components and build powerful and interactive user interfaces in your React.js applications. It simplifies state management and eliminates the need to write class components for managing state.


### Below is a list of some commonly used events in React.js, along with simple descriptions of each:

```
 ____________________________________________
| Event       | Description                    |
|_____________|________________________________|
| onClick     | Triggered when an element is    |
|             | clicked or tapped by the user.  |
|_____________|________________________________|
| onChange    | Triggered when the value of an  |
|             | input element (like a text      |
|             | input, checkbox, or dropdown)   |
|             | changes.                        |
|_____________|________________________________|
| onSubmit    | Triggered when a form is        |
|             | submitted by the user.          |
|_____________|________________________________|
| onMouseOver | Triggered when the mouse        |
|             | pointer is moved over an        |
|             | element.                        |
|_____________|________________________________|
| onMouseOut  | Triggered when the mouse        |
|             | pointer leaves an element.      |
|_____________|________________________________|
| onFocus     | Triggered when an element       |
|             | receives focus (e.g., when a     |
|             | user clicks on an input field).  |
|_____________|________________________________|
| onBlur      | Triggered when an element loses |
|             | focus (e.g., when a user clicks  |
|             | away from an input field).      |
|_____________|________________________________|
| onKeyDown   | Triggered when a key is pressed  |
|             | down.                           |
|_____________|________________________________|
| onKeyUp     | Triggered when a key is released|
|_____________|________________________________|
| onScroll    | Triggered when an element is    |
|             | scrolled.                       |
|_____________|________________________________|
| onResize    | Triggered when the browser      |
|             | window is resized.              |
|_____________|________________________________|
| onHover     | There is no specific "onHover"  |
|             | event in React.js. Instead,     |
|             | you can use "onMouseOver" and   |
|             | "onMouseOut" to achieve the     |
|             | hover effect.                   |
|_____________|________________________________|
```

Please note that this is not an exhaustive list, as React.js supports many more events. However, the events listed above are some of the most commonly used ones. Each event is associated with specific user interactions, and you can use them to build interactive and responsive user interfaces in your React.js applications.

## Best Practices for Event Handling in React.js

### 1. Use arrow functions to define event handlers

The first best practice is to use arrow functions to bind "this" when defining event handler functions in React.js.

In React.js, event handlers are functions that are invoked when a specific event occurs, such as a button click or an input field change. When defining an event handler function using a traditional function expression, the value of "this" inside the function may not refer to the component instance, causing potential issues when accessing component properties or methods.

To solve this problem, we can use arrow functions instead of traditional function expressions. Arrow functions automatically capture the value of "this" from the surrounding context, which means that "this" inside the arrow function will always refer to the component instance.

Here's an example to illustrate the difference between using a traditional function expression and an arrow function for an event handler:

**Bad Practice (Traditional Function Expression):**
```jsx
class MyComponent extends React.Component {
  handleClick() {
    console.log(this.props.value); // 'this' may not refer to the component instance!
  }

  render() {
    return (
      <button onClick={this.handleClick}>Click me!</button>
    );
  }
}
```

In the above example, when the button is clicked, the `handleClick` function is called, but "this" inside the function may not refer to the component instance. As a result, `this.props.value` might be undefined or point to something unexpected.

**Good Practice (Arrow Function):**
```jsx
class MyComponent extends React.Component {
  handleClick = () => {
    console.log(this.props.value); // 'this' will always refer to the component instance!
  }

  render() {
    return (
      <button onClick={this.handleClick}>Click me!</button>
    );
  }
}
```

In the second example, we use an arrow function to define the `handleClick` event handler. Now, when the button is clicked, "this" inside the arrow function will always refer to the component instance, ensuring that `this.props.value` correctly accesses the component's props.

By using arrow functions for event handlers, we ensure that the value of "this" is correctly bound to the component instance, making it easier and safer to access component properties and methods inside the event handler. This is a best practice that can help avoid common pitfalls and improve the overall readability and maintainability of your React.js code.

# App.js

```jsx

import React from 'react';
import MyComponent from './MyComponent';

const App = () => {
  return (
    <div>
      <MyComponent value="Hello, Nikita!" />
    </div>
  );
};

export default App;

```

# MyComponent.js

```jsx  
import React from 'react';

class MyComponent extends React.Component {
      handleClick = () => {
        console.log(this.props.value); // 'this' will always refer to the component instance!
      };
    // handleClick ()  {
    //     console.log(this.props.value); // 'this' may not always refer to the component instance!
    // };

    render() {
        return (
            <button onClick={this.handleClick}>Click me!</button>
        );
    }
}

export default MyComponent;

```

### 2. Use the "preventDefault" method to prevent default behavior

The second best practice is to use `event.preventDefault()` to prevent the default behavior of certain dynamic events in React.js.

In React.js, dynamic events like form submissions or link clicks may have default behaviors associated with them. For example, when a user clicks on a submit button inside a form, the default behavior is to submit the form, leading to a page refresh. However, there might be cases where you want to override this default behavior and perform some other actions without triggering the default behavior.

To achieve this, you can use the `event.preventDefault()` method within your event handler. When called, this method prevents the default behavior of the event from happening, giving you the control to handle the event as needed.

Here's an example to demonstrate how to use `event.preventDefault()`:

```jsx
class MyForm extends React.Component {
  handleSubmit = (event) => {
    event.preventDefault(); // Prevent the default form submission behavior

    // Custom logic to handle the form submission
    const formData = new FormData(event.target);
    // Process the form data and perform any desired actions

    console.log("Form submitted!");
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <input type="text" name="username" placeholder="Enter your username" />
        <button type="submit">Submit</button>
      </form>
    );
  }
}
```

In this example, we have a form with an input field and a submit button. When the user clicks the "Submit" button, the `handleSubmit` event handler is called. By using `event.preventDefault()`, we prevent the default form submission behavior, which means the page won't refresh.

Instead, we have control over the form submission and can access the form data using the `event.target` property. You can then perform any custom logic, such as sending the form data to a server, validating the input, or updating the UI accordingly.

Using `event.preventDefault()` is particularly useful when you need to perform asynchronous tasks, such as making API calls, before completing the default behavior. It allows you to handle dynamic events in a more controlled and flexible manner, making your React.js applications more user-friendly and interactive.

# App.js

```jsx
import React from 'react';
import MyComponent from './MyComponent'; // Make sure to provide the correct path to MyForm.js

const App = () => {
  return (
    <div>
      <h1>Welcome to My Form App</h1>
      <MyComponent />
    </div>
  );
};

export default App;
    
```

# MyComponent.js

```jsx
import React from 'react';

class MyForm extends React.Component {
    handleSubmit = (event) => {
        event.preventDefault(); // Prevent the default form submission behavior

        // Custom logic to handle the form submission
        const formData = new FormData(event.target);
        // Process the form data and perform any desired actions

        console.log("Form submitted!");
    }

    render() {
        return (
            <form onSubmit={this.handleSubmit}>
                <input type="text" name="username" placeholder="Enter your username" />
                <button type="submit">Submit</button>
            </form>
        );
    }
}

export default MyForm;
```

## 3. Use the event.stopPropagation method to stop event propagation

The third best practice is to use `event.stopPropagation()` to stop event propagation in React.js.

In React.js, event propagation refers to the process of an event bubbling up through the component hierarchy. When an event occurs on a child element, it can trigger the same event on its parent elements in the component tree. This is called event bubbling. Sometimes, you may want to prevent this event from propagating further up the tree, and that's where `event.stopPropagation()` comes in handy.

Let's understand this with a code example:

```jsx
class ParentComponent extends React.Component {
  handleParentClick = () => {
    console.log("Parent component clicked!");
  }

  render() {
    return (
      <div onClick={this.handleParentClick}>
        <ChildComponent />
      </div>
    );
  }
}

class ChildComponent extends React.Component {
  handleChildClick = (event) => {
    event.stopPropagation(); // Prevent the click event from bubbling to the parent

    console.log("Child component clicked!");
  }

  render() {
    return (
      <button onClick={this.handleChildClick}>Click Me</button>
    );
  }
}
```

In this example, we have a `ParentComponent` that contains a `ChildComponent`. Both components have their own click event handlers. When you click the "Click Me" button inside the `ChildComponent`, the event will bubble up to the `ParentComponent` due to event propagation.

However, by using `event.stopPropagation()` in the `handleChildClick` event handler, we prevent the click event from propagating further up to the parent. As a result, only the `handleChildClick` function will be executed, and the "Parent component clicked!" message won't be logged in the console.

This technique is useful when you want to handle events at a specific level in the component tree without affecting parent components. It allows you to control how events are handled in nested components and ensures that the event is isolated to the intended component.

Remember that while `event.stopPropagation()` can be helpful in certain scenarios, using it excessively may lead to a less predictable event flow and make the application harder to maintain. So, use it judiciously and only when it's necessary to prevent unwanted event bubbling.

# App.js

```jsx

import React from 'react';
import ParentComponent from './ParentComponent';

function App() {
  return (
    <div>
      <ParentComponent />
    </div>
  );
}

export default App;


```

# MyParentComponent.js

```jsx
import React from 'react';
import ChildComponent from './ChildComponent';

class ParentComponent extends React.Component {
  handleParentClick = () => {
    console.log("Parent component clicked!");
  }

  render() {
    return (
      <div onClick={this.handleParentClick}>
        <ChildComponent />
      </div>
    );
  }
}

export default ParentComponent;

```

# MyChildComponent.js

```jsx
import React from 'react';

class ChildComponent extends React.Component {
  handleChildClick = (event) => {
    event.stopPropagation(); // Prevent the click event from bubbling to the parent

    console.log("Child component clicked!");
  }

  render() {
    return (
      <button onClick={this.handleChildClick}>Click Me</button>
    );
  }
}

export default ChildComponent;

```

## 4. Use the event.persist method to access event properties asynchronously

The fourth best practice is to use `event.persist()` to access event properties asynchronously in React.js.

In React.js, when handling dynamic events, you may encounter situations where you need to access event properties inside asynchronous code, such as in a `setTimeout` or a `Promise` callback. However, by the time the asynchronous code is executed, the event object might have been reused by the system, and its properties might have been cleared or become null. This can lead to unexpected behavior or errors when trying to access event properties asynchronously.

To address this issue, React provides the `event.persist()` method. When you call `event.persist()`, React will remove the synthetic event from the pool of reusable events, which means that the event will not be recycled after the current tick. As a result, you can access event properties asynchronously without worrying about them being cleared or changed.

Let's see how to use `event.persist()` with a code example:

```jsx
class MyComponent extends React.Component {
  handleClick = (event) => {
    event.persist(); // Persist the event to access its properties asynchronously

    setTimeout(() => {
      console.log("Target value:", event.target.value);
    }, 1000);
  }

  render() {
    return (
      <input type="text" onChange={this.handleClick} placeholder="Type something..." />
    );
  }
}
```

In this example, we have a `MyComponent` with an input field. When the user types something into the input field, the `onChange` event is triggered, and the `handleClick` event handler is called.

Inside the `handleClick` event handler, we use `event.persist()` to persist the event. Then, we set up a `setTimeout` function that will be executed after a delay of one second. Inside the `setTimeout` callback, we try to access the `target.value` property of the event.

Without `event.persist()`, accessing `event.target.value` inside the `setTimeout` callback would lead to an error because the event would have been recycled by the time the callback is executed. However, by using `event.persist()`, we ensure that the event is not recycled, and we can safely access its properties asynchronously.

With `event.persist()`, you can confidently access event properties inside asynchronous code without worrying about potential issues caused by event recycling. This is particularly useful when you need to perform asynchronous operations based on user input events and want to access event properties inside those asynchronous operations.

#### Explain like I'm five (ELI5) version

Imagine you have a toy car that makes a sound when you press its button. Now, let's say you want to record how many times the button was pressed after 1 second. But when you try to check the count after 1 second, the car has already forgotten how many times you pressed the button. To solve this, you need to write down the count right after pressing the button.

In React.js, it's similar. When you handle certain events, like typing or clicking, React gives you an event object that contains information about what happened. However, if you try to use that information in some delayed action, React might forget it before that action takes place. So, we use `event.persist()` to make sure React doesn't forget and keeps the event information for us.

Here's a simple example:

```jsx
import React from 'react';

class MyComponent extends React.Component {
  handleClick = (event) => {
    event.persist(); // Remember the event information for later

    setTimeout(() => {
      console.log("You clicked!");
      console.log("Button value:", event.target.value);
    }, 1000);
  }

  render() {
    return (
      <button onClick={this.handleClick}>Click Me!</button>
    );
  }
}

export default MyComponent;
```

In this example, we have a component called `MyComponent` with a button. When you click the button, the `handleClick` event handler is called.

Inside the `handleClick` event handler, we use `event.persist()` to make React remember the event information even after a delay. Then, we set up a `setTimeout` function that will be executed after a delay of one second (1000 milliseconds). Inside the `setTimeout` callback, we log two messages to the console: "You clicked!" and the value of the button.

Without `event.persist()`, the value of the button inside the `setTimeout` callback would be undefined because React would have forgotten the event information. But by using `event.persist()`, we ensure that React remembers the event information and we can use it even after a delay.

To run this code, create a new file (e.g., `MyComponent.js`) in your React project and add the code above. Then, you can use this `MyComponent` in your `App.js` or any other component to render the button.

# App.js

```jsx
import React from 'react';
import MyComponent from './MyComponent';

function App() {
  return (
    <div className="App">
      <h1>Click the Button!</h1>
      <MyComponent />
    </div>
  );
}

export default App;

```

# MyComponent.js

```jsx
import React, { useState } from 'react';

const MyComponent = () => {
  const [clickCount, setClickCount] = useState(0);

  const handleClick = () => {
    setClickCount((prevCount) => prevCount + 1);
    setTimeout(() => {
      setClickCount((prevCount) => prevCount - 1);
    }, 1000);
  };

  return (
    <div>
      <button onClick={handleClick}>Click me!</button>
      <p>Number of clicks: {clickCount}</p>
    </div>
  );
};

export default MyComponent;

```

### Short Revised Notes

1. Dynamic Events in React.js
   - Events are actions or changes that occur while a program runs.
   - In React.js, dynamic events are like buttons that trigger actions in response to user interactions.

2. Creating Event Handlers in React.js
   - Event handlers are functions that specify what to do when an event occurs.
   - Use arrow functions to ensure `this` refers to the component instance correctly.
   - Example: `<button onClick={() => alert('Button clicked!')}>Click me!</button>`

3. Best Practices for Event Handling in React.js
   - Use `event.preventDefault()` to prevent default behavior (e.g., form submission).
   - Use `event.stopPropagation()` to stop event propagation and handle events at specific levels.
   - Use `event.persist()` to access event properties asynchronously (e.g., inside `setTimeout`).
   - Persist the event to avoid losing event data after a delay.

By following these best practices, you can handle dynamic events effectively and create interactive and responsive user interfaces in your React.js applications.

